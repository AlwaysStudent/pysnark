Programming guide
=================

This section discusses how to specify verifiable computations using PySNARK.

Introduction to verifiable computation
--------------------------------------

In a verifiable computation, a prover proves to a verifier that certain I/O known by the verifier satisfies a certain relation.
For instance, the I/O may be the two values 2 and 8 and the relation may be that the second I/O value is the cube of the first I/O value.
The prover creates a crypgraphic proof (using an evaluation key depending on the computation performed and generated by a trusted third party) that the verifier uses to verify (using a verification key generated by the same trusted third party) that the I/O it received (2 and 8, in this case), satisfy the given relation (in this case, that the second I/O value is the cube of the first I/O value).

Apart from referring to public I/O, the proof may also refer to secret values known only to the verifier, so-called witnesses. For instance, the public I/O may be the image of a cryptographic hash function (see :py:mod:`pysnark.lib.ggh`) in which case the prover may prove that it knows the pre-image that gives te resulting value when applying the hash function.
In this case, the pre-image is the witness.
Note that PySNARK will also generate many witnesses implicitly during the computation, e.g., to compute ``y=x*x*x`` PySNARK will actually internally create a witness ``z`` such that ``z=x*x`` and ``y=x*z``.

Finally, the prover may in a proof refer to externally committed data, typically provided by a third party other than the trusted third party or the prover itself.
For instance, party A publishes a commitment to a sensitive dataset, allowing B (who has access to the dataset) to prove properties about this dataset to party C (who does not learn the dataset, only that B's proof was correct with respect to the data committed to by A), all based on key material generated once by a trusted third party D.

Basics: variables and proof generation
--------------------------------------

Verifiable computations are programmed using the PySNARK runtime, :py:mod:`pysnark.runtime`.

Values used in a verifiable computation are called variables and are instances of :py:class:`pysnark.runtime.Var`.
Instances of this class can represent I/O, witnessess, or committed data.

To create an I/O variable with a given value, use :py:meth:`pysnark.runtime.Var.__init__` with a value and optionally a name for the variable (this name will appear in the I/O file that PySNARK outputs), e.g.: ::

  from pysnark.runtime import Var
  
  in = Var(int(sys.argv[1]), "in")

PySNARK variables can be manipulated using normal operators, e.g., for addition, multiplication, and sutraction.
(These computations are actually performed modulo a large prime number :py:data:`pysnark.options.vc_p` but this usually does not make a difference in practice.)
For instance, one computes the cube of ``in`` as follows: ::

  cube = in*in*in

Here, ``cube`` is a witness of the computation. To output this value, i.e., to turn it into a piece of I/O, use the :py:func:`pysnark.runtime.Var.val` function, optionally with a name to use for the variable: ::

  print "The cubed value is", cube.val("out")

To create a witness, call :py:meth:`pysnark.runtime.Var.__init__` with ``True`` as variable name, e.g.: ::

  wit = Var(33, True) # this is not I/O
  
Just instantiating Var itself does not cause PySNARK to create verifiable computation proofs.
For this, import the :py:mod:`pysnark.prove` module: importing this module will register an exit handler causing PySNARK to build and verify a proof when the Python script terminates.


Division into subcomputations
-----------------------------

Use the :py:func:`pysnark.runtime.subqap` decorator.

How PySNARK works internally
----------------------------

Keeping computations secret
---------------------------

If the computation is supposed to be secret, use :py:func:`pysnark.runtime.Var.constant` instead of plain constants: the values of any constants applied to I/O values can be derived from the public verification key. Also, keep the verification key secret.
